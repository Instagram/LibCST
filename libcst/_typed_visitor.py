# Copyright (c) Facebook, Inc. and its affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.

# pyre-strict

# This file was generated by libcst.codegen.gen_matcher_classes
from typing import TYPE_CHECKING, Optional, Union

from libcst._maybe_sentinel import MaybeSentinel
from libcst._removal_sentinel import RemovalSentinel
from libcst._typed_visitor_base import mark_no_op


if TYPE_CHECKING:
    from libcst._nodes._op import (  # noqa: F401
        Add,
        AddAssign,
        And,
        AssignEqual,
        BaseAugOp,
        BaseBinaryOp,
        BaseBooleanOp,
        BaseCompOp,
        BaseUnaryOp,
        BitAnd,
        BitAndAssign,
        BitInvert,
        BitOr,
        BitOrAssign,
        BitXor,
        BitXorAssign,
        Colon,
        Comma,
        Divide,
        DivideAssign,
        Dot,
        Equal,
        FloorDivide,
        FloorDivideAssign,
        GreaterThan,
        GreaterThanEqual,
        ImportStar,
        In,
        Is,
        IsNot,
        LeftShift,
        LeftShiftAssign,
        LessThan,
        LessThanEqual,
        MatrixMultiply,
        MatrixMultiplyAssign,
        Minus,
        Modulo,
        ModuloAssign,
        Multiply,
        MultiplyAssign,
        Not,
        NotEqual,
        NotIn,
        Or,
        Plus,
        Power,
        PowerAssign,
        RightShift,
        RightShiftAssign,
        Semicolon,
        Subtract,
        SubtractAssign,
    )
    from libcst._nodes._statement import (  # noqa: F401
        AnnAssign,
        AsName,
        Assert,
        Assign,
        AssignTarget,
        AugAssign,
        BaseSmallStatement,
        BaseStatement,
        BaseSuite,
        Break,
        ClassDef,
        Continue,
        Decorator,
        Del,
        Else,
        ExceptHandler,
        Expr,
        Finally,
        For,
        FunctionDef,
        Global,
        If,
        Import,
        ImportAlias,
        ImportFrom,
        IndentedBlock,
        NameItem,
        Nonlocal,
        Pass,
        Raise,
        Return,
        SimpleStatementLine,
        SimpleStatementSuite,
        Try,
        While,
        With,
        WithItem,
    )
    from libcst._nodes._expression import (  # noqa: F401
        Annotation,
        Arg,
        Asynchronous,
        Attribute,
        Await,
        BaseDictElement,
        BaseElement,
        BaseExpression,
        BaseFormattedStringContent,
        BinaryOperation,
        BooleanOperation,
        Call,
        CompFor,
        CompIf,
        Comparison,
        ComparisonTarget,
        ConcatenatedString,
        Dict,
        DictComp,
        DictElement,
        Element,
        Ellipsis,
        ExtSlice,
        Float,
        FormattedString,
        FormattedStringExpression,
        FormattedStringText,
        From,
        GeneratorExp,
        IfExp,
        Imaginary,
        Index,
        Integer,
        Lambda,
        LeftCurlyBrace,
        LeftParen,
        LeftSquareBracket,
        List,
        ListComp,
        Name,
        Param,
        ParamStar,
        Parameters,
        RightCurlyBrace,
        RightParen,
        RightSquareBracket,
        Set,
        SetComp,
        SimpleString,
        Slice,
        StarredDictElement,
        StarredElement,
        Subscript,
        Tuple,
        UnaryOperation,
        Yield,
    )
    from libcst._nodes._whitespace import (  # noqa: F401
        BaseParenthesizableWhitespace,
        Comment,
        EmptyLine,
        Newline,
        ParenthesizedWhitespace,
        SimpleWhitespace,
        TrailingWhitespace,
    )
    from libcst._nodes._module import Module  # noqa: F401


class CSTTypedBaseFunctions:
    @mark_no_op
    def visit_Add(self, node: "Add") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_AddAssign(self, node: "AddAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_And(self, node: "And") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_AnnAssign(self, node: "AnnAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Annotation(self, node: "Annotation") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Arg(self, node: "Arg") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_AsName(self, node: "AsName") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Assert(self, node: "Assert") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Assign(self, node: "Assign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_AssignEqual(self, node: "AssignEqual") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_AssignTarget(self, node: "AssignTarget") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Asynchronous(self, node: "Asynchronous") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Attribute(self, node: "Attribute") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_AugAssign(self, node: "AugAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Await(self, node: "Await") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BinaryOperation(self, node: "BinaryOperation") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BitAnd(self, node: "BitAnd") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BitAndAssign(self, node: "BitAndAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BitInvert(self, node: "BitInvert") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BitOr(self, node: "BitOr") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BitOrAssign(self, node: "BitOrAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BitXor(self, node: "BitXor") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BitXorAssign(self, node: "BitXorAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_BooleanOperation(self, node: "BooleanOperation") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Break(self, node: "Break") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Call(self, node: "Call") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ClassDef(self, node: "ClassDef") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Colon(self, node: "Colon") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Comma(self, node: "Comma") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Comment(self, node: "Comment") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_CompFor(self, node: "CompFor") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_CompIf(self, node: "CompIf") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Comparison(self, node: "Comparison") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ComparisonTarget(self, node: "ComparisonTarget") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ConcatenatedString(self, node: "ConcatenatedString") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Continue(self, node: "Continue") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Decorator(self, node: "Decorator") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Del(self, node: "Del") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Dict(self, node: "Dict") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_DictComp(self, node: "DictComp") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_DictElement(self, node: "DictElement") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Divide(self, node: "Divide") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_DivideAssign(self, node: "DivideAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Dot(self, node: "Dot") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Element(self, node: "Element") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Ellipsis(self, node: "Ellipsis") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Else(self, node: "Else") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_EmptyLine(self, node: "EmptyLine") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Equal(self, node: "Equal") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ExceptHandler(self, node: "ExceptHandler") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Expr(self, node: "Expr") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ExtSlice(self, node: "ExtSlice") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Finally(self, node: "Finally") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Float(self, node: "Float") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_FloorDivide(self, node: "FloorDivide") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_FloorDivideAssign(self, node: "FloorDivideAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_For(self, node: "For") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_FormattedString(self, node: "FormattedString") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_FormattedStringExpression(
        self, node: "FormattedStringExpression"
    ) -> Optional[bool]:
        pass

    @mark_no_op
    def visit_FormattedStringText(self, node: "FormattedStringText") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_From(self, node: "From") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_FunctionDef(self, node: "FunctionDef") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_GeneratorExp(self, node: "GeneratorExp") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Global(self, node: "Global") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_GreaterThan(self, node: "GreaterThan") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_GreaterThanEqual(self, node: "GreaterThanEqual") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_If(self, node: "If") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_IfExp(self, node: "IfExp") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Imaginary(self, node: "Imaginary") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Import(self, node: "Import") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ImportAlias(self, node: "ImportAlias") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ImportFrom(self, node: "ImportFrom") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ImportStar(self, node: "ImportStar") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_In(self, node: "In") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_IndentedBlock(self, node: "IndentedBlock") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Index(self, node: "Index") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Integer(self, node: "Integer") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Is(self, node: "Is") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_IsNot(self, node: "IsNot") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Lambda(self, node: "Lambda") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_LeftCurlyBrace(self, node: "LeftCurlyBrace") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_LeftParen(self, node: "LeftParen") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_LeftShift(self, node: "LeftShift") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_LeftShiftAssign(self, node: "LeftShiftAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_LeftSquareBracket(self, node: "LeftSquareBracket") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_LessThan(self, node: "LessThan") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_LessThanEqual(self, node: "LessThanEqual") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_List(self, node: "List") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ListComp(self, node: "ListComp") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_MatrixMultiply(self, node: "MatrixMultiply") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_MatrixMultiplyAssign(
        self, node: "MatrixMultiplyAssign"
    ) -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Minus(self, node: "Minus") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Module(self, node: "Module") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Modulo(self, node: "Modulo") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ModuloAssign(self, node: "ModuloAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Multiply(self, node: "Multiply") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_MultiplyAssign(self, node: "MultiplyAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Name(self, node: "Name") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_NameItem(self, node: "NameItem") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Newline(self, node: "Newline") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Nonlocal(self, node: "Nonlocal") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Not(self, node: "Not") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_NotEqual(self, node: "NotEqual") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_NotIn(self, node: "NotIn") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Or(self, node: "Or") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Param(self, node: "Param") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ParamStar(self, node: "ParamStar") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Parameters(self, node: "Parameters") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_ParenthesizedWhitespace(
        self, node: "ParenthesizedWhitespace"
    ) -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Pass(self, node: "Pass") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Plus(self, node: "Plus") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Power(self, node: "Power") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_PowerAssign(self, node: "PowerAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Raise(self, node: "Raise") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Return(self, node: "Return") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_RightCurlyBrace(self, node: "RightCurlyBrace") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_RightParen(self, node: "RightParen") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_RightShift(self, node: "RightShift") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_RightShiftAssign(self, node: "RightShiftAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_RightSquareBracket(self, node: "RightSquareBracket") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Semicolon(self, node: "Semicolon") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Set(self, node: "Set") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_SetComp(self, node: "SetComp") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_SimpleStatementLine(self, node: "SimpleStatementLine") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_SimpleStatementSuite(
        self, node: "SimpleStatementSuite"
    ) -> Optional[bool]:
        pass

    @mark_no_op
    def visit_SimpleString(self, node: "SimpleString") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_SimpleWhitespace(self, node: "SimpleWhitespace") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Slice(self, node: "Slice") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_StarredDictElement(self, node: "StarredDictElement") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_StarredElement(self, node: "StarredElement") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Subscript(self, node: "Subscript") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Subtract(self, node: "Subtract") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_SubtractAssign(self, node: "SubtractAssign") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_TrailingWhitespace(self, node: "TrailingWhitespace") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Try(self, node: "Try") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Tuple(self, node: "Tuple") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_UnaryOperation(self, node: "UnaryOperation") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_While(self, node: "While") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_With(self, node: "With") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_WithItem(self, node: "WithItem") -> Optional[bool]:
        pass

    @mark_no_op
    def visit_Yield(self, node: "Yield") -> Optional[bool]:
        pass


class CSTTypedVisitorFunctions(CSTTypedBaseFunctions):
    @mark_no_op
    def leave_Add(self, original_node: "Add") -> None:
        pass

    @mark_no_op
    def leave_AddAssign(self, original_node: "AddAssign") -> None:
        pass

    @mark_no_op
    def leave_And(self, original_node: "And") -> None:
        pass

    @mark_no_op
    def leave_AnnAssign(self, original_node: "AnnAssign") -> None:
        pass

    @mark_no_op
    def leave_Annotation(self, original_node: "Annotation") -> None:
        pass

    @mark_no_op
    def leave_Arg(self, original_node: "Arg") -> None:
        pass

    @mark_no_op
    def leave_AsName(self, original_node: "AsName") -> None:
        pass

    @mark_no_op
    def leave_Assert(self, original_node: "Assert") -> None:
        pass

    @mark_no_op
    def leave_Assign(self, original_node: "Assign") -> None:
        pass

    @mark_no_op
    def leave_AssignEqual(self, original_node: "AssignEqual") -> None:
        pass

    @mark_no_op
    def leave_AssignTarget(self, original_node: "AssignTarget") -> None:
        pass

    @mark_no_op
    def leave_Asynchronous(self, original_node: "Asynchronous") -> None:
        pass

    @mark_no_op
    def leave_Attribute(self, original_node: "Attribute") -> None:
        pass

    @mark_no_op
    def leave_AugAssign(self, original_node: "AugAssign") -> None:
        pass

    @mark_no_op
    def leave_Await(self, original_node: "Await") -> None:
        pass

    @mark_no_op
    def leave_BinaryOperation(self, original_node: "BinaryOperation") -> None:
        pass

    @mark_no_op
    def leave_BitAnd(self, original_node: "BitAnd") -> None:
        pass

    @mark_no_op
    def leave_BitAndAssign(self, original_node: "BitAndAssign") -> None:
        pass

    @mark_no_op
    def leave_BitInvert(self, original_node: "BitInvert") -> None:
        pass

    @mark_no_op
    def leave_BitOr(self, original_node: "BitOr") -> None:
        pass

    @mark_no_op
    def leave_BitOrAssign(self, original_node: "BitOrAssign") -> None:
        pass

    @mark_no_op
    def leave_BitXor(self, original_node: "BitXor") -> None:
        pass

    @mark_no_op
    def leave_BitXorAssign(self, original_node: "BitXorAssign") -> None:
        pass

    @mark_no_op
    def leave_BooleanOperation(self, original_node: "BooleanOperation") -> None:
        pass

    @mark_no_op
    def leave_Break(self, original_node: "Break") -> None:
        pass

    @mark_no_op
    def leave_Call(self, original_node: "Call") -> None:
        pass

    @mark_no_op
    def leave_ClassDef(self, original_node: "ClassDef") -> None:
        pass

    @mark_no_op
    def leave_Colon(self, original_node: "Colon") -> None:
        pass

    @mark_no_op
    def leave_Comma(self, original_node: "Comma") -> None:
        pass

    @mark_no_op
    def leave_Comment(self, original_node: "Comment") -> None:
        pass

    @mark_no_op
    def leave_CompFor(self, original_node: "CompFor") -> None:
        pass

    @mark_no_op
    def leave_CompIf(self, original_node: "CompIf") -> None:
        pass

    @mark_no_op
    def leave_Comparison(self, original_node: "Comparison") -> None:
        pass

    @mark_no_op
    def leave_ComparisonTarget(self, original_node: "ComparisonTarget") -> None:
        pass

    @mark_no_op
    def leave_ConcatenatedString(self, original_node: "ConcatenatedString") -> None:
        pass

    @mark_no_op
    def leave_Continue(self, original_node: "Continue") -> None:
        pass

    @mark_no_op
    def leave_Decorator(self, original_node: "Decorator") -> None:
        pass

    @mark_no_op
    def leave_Del(self, original_node: "Del") -> None:
        pass

    @mark_no_op
    def leave_Dict(self, original_node: "Dict") -> None:
        pass

    @mark_no_op
    def leave_DictComp(self, original_node: "DictComp") -> None:
        pass

    @mark_no_op
    def leave_DictElement(self, original_node: "DictElement") -> None:
        pass

    @mark_no_op
    def leave_Divide(self, original_node: "Divide") -> None:
        pass

    @mark_no_op
    def leave_DivideAssign(self, original_node: "DivideAssign") -> None:
        pass

    @mark_no_op
    def leave_Dot(self, original_node: "Dot") -> None:
        pass

    @mark_no_op
    def leave_Element(self, original_node: "Element") -> None:
        pass

    @mark_no_op
    def leave_Ellipsis(self, original_node: "Ellipsis") -> None:
        pass

    @mark_no_op
    def leave_Else(self, original_node: "Else") -> None:
        pass

    @mark_no_op
    def leave_EmptyLine(self, original_node: "EmptyLine") -> None:
        pass

    @mark_no_op
    def leave_Equal(self, original_node: "Equal") -> None:
        pass

    @mark_no_op
    def leave_ExceptHandler(self, original_node: "ExceptHandler") -> None:
        pass

    @mark_no_op
    def leave_Expr(self, original_node: "Expr") -> None:
        pass

    @mark_no_op
    def leave_ExtSlice(self, original_node: "ExtSlice") -> None:
        pass

    @mark_no_op
    def leave_Finally(self, original_node: "Finally") -> None:
        pass

    @mark_no_op
    def leave_Float(self, original_node: "Float") -> None:
        pass

    @mark_no_op
    def leave_FloorDivide(self, original_node: "FloorDivide") -> None:
        pass

    @mark_no_op
    def leave_FloorDivideAssign(self, original_node: "FloorDivideAssign") -> None:
        pass

    @mark_no_op
    def leave_For(self, original_node: "For") -> None:
        pass

    @mark_no_op
    def leave_FormattedString(self, original_node: "FormattedString") -> None:
        pass

    @mark_no_op
    def leave_FormattedStringExpression(
        self, original_node: "FormattedStringExpression"
    ) -> None:
        pass

    @mark_no_op
    def leave_FormattedStringText(self, original_node: "FormattedStringText") -> None:
        pass

    @mark_no_op
    def leave_From(self, original_node: "From") -> None:
        pass

    @mark_no_op
    def leave_FunctionDef(self, original_node: "FunctionDef") -> None:
        pass

    @mark_no_op
    def leave_GeneratorExp(self, original_node: "GeneratorExp") -> None:
        pass

    @mark_no_op
    def leave_Global(self, original_node: "Global") -> None:
        pass

    @mark_no_op
    def leave_GreaterThan(self, original_node: "GreaterThan") -> None:
        pass

    @mark_no_op
    def leave_GreaterThanEqual(self, original_node: "GreaterThanEqual") -> None:
        pass

    @mark_no_op
    def leave_If(self, original_node: "If") -> None:
        pass

    @mark_no_op
    def leave_IfExp(self, original_node: "IfExp") -> None:
        pass

    @mark_no_op
    def leave_Imaginary(self, original_node: "Imaginary") -> None:
        pass

    @mark_no_op
    def leave_Import(self, original_node: "Import") -> None:
        pass

    @mark_no_op
    def leave_ImportAlias(self, original_node: "ImportAlias") -> None:
        pass

    @mark_no_op
    def leave_ImportFrom(self, original_node: "ImportFrom") -> None:
        pass

    @mark_no_op
    def leave_ImportStar(self, original_node: "ImportStar") -> None:
        pass

    @mark_no_op
    def leave_In(self, original_node: "In") -> None:
        pass

    @mark_no_op
    def leave_IndentedBlock(self, original_node: "IndentedBlock") -> None:
        pass

    @mark_no_op
    def leave_Index(self, original_node: "Index") -> None:
        pass

    @mark_no_op
    def leave_Integer(self, original_node: "Integer") -> None:
        pass

    @mark_no_op
    def leave_Is(self, original_node: "Is") -> None:
        pass

    @mark_no_op
    def leave_IsNot(self, original_node: "IsNot") -> None:
        pass

    @mark_no_op
    def leave_Lambda(self, original_node: "Lambda") -> None:
        pass

    @mark_no_op
    def leave_LeftCurlyBrace(self, original_node: "LeftCurlyBrace") -> None:
        pass

    @mark_no_op
    def leave_LeftParen(self, original_node: "LeftParen") -> None:
        pass

    @mark_no_op
    def leave_LeftShift(self, original_node: "LeftShift") -> None:
        pass

    @mark_no_op
    def leave_LeftShiftAssign(self, original_node: "LeftShiftAssign") -> None:
        pass

    @mark_no_op
    def leave_LeftSquareBracket(self, original_node: "LeftSquareBracket") -> None:
        pass

    @mark_no_op
    def leave_LessThan(self, original_node: "LessThan") -> None:
        pass

    @mark_no_op
    def leave_LessThanEqual(self, original_node: "LessThanEqual") -> None:
        pass

    @mark_no_op
    def leave_List(self, original_node: "List") -> None:
        pass

    @mark_no_op
    def leave_ListComp(self, original_node: "ListComp") -> None:
        pass

    @mark_no_op
    def leave_MatrixMultiply(self, original_node: "MatrixMultiply") -> None:
        pass

    @mark_no_op
    def leave_MatrixMultiplyAssign(self, original_node: "MatrixMultiplyAssign") -> None:
        pass

    @mark_no_op
    def leave_Minus(self, original_node: "Minus") -> None:
        pass

    @mark_no_op
    def leave_Module(self, original_node: "Module") -> None:
        pass

    @mark_no_op
    def leave_Modulo(self, original_node: "Modulo") -> None:
        pass

    @mark_no_op
    def leave_ModuloAssign(self, original_node: "ModuloAssign") -> None:
        pass

    @mark_no_op
    def leave_Multiply(self, original_node: "Multiply") -> None:
        pass

    @mark_no_op
    def leave_MultiplyAssign(self, original_node: "MultiplyAssign") -> None:
        pass

    @mark_no_op
    def leave_Name(self, original_node: "Name") -> None:
        pass

    @mark_no_op
    def leave_NameItem(self, original_node: "NameItem") -> None:
        pass

    @mark_no_op
    def leave_Newline(self, original_node: "Newline") -> None:
        pass

    @mark_no_op
    def leave_Nonlocal(self, original_node: "Nonlocal") -> None:
        pass

    @mark_no_op
    def leave_Not(self, original_node: "Not") -> None:
        pass

    @mark_no_op
    def leave_NotEqual(self, original_node: "NotEqual") -> None:
        pass

    @mark_no_op
    def leave_NotIn(self, original_node: "NotIn") -> None:
        pass

    @mark_no_op
    def leave_Or(self, original_node: "Or") -> None:
        pass

    @mark_no_op
    def leave_Param(self, original_node: "Param") -> None:
        pass

    @mark_no_op
    def leave_ParamStar(self, original_node: "ParamStar") -> None:
        pass

    @mark_no_op
    def leave_Parameters(self, original_node: "Parameters") -> None:
        pass

    @mark_no_op
    def leave_ParenthesizedWhitespace(
        self, original_node: "ParenthesizedWhitespace"
    ) -> None:
        pass

    @mark_no_op
    def leave_Pass(self, original_node: "Pass") -> None:
        pass

    @mark_no_op
    def leave_Plus(self, original_node: "Plus") -> None:
        pass

    @mark_no_op
    def leave_Power(self, original_node: "Power") -> None:
        pass

    @mark_no_op
    def leave_PowerAssign(self, original_node: "PowerAssign") -> None:
        pass

    @mark_no_op
    def leave_Raise(self, original_node: "Raise") -> None:
        pass

    @mark_no_op
    def leave_Return(self, original_node: "Return") -> None:
        pass

    @mark_no_op
    def leave_RightCurlyBrace(self, original_node: "RightCurlyBrace") -> None:
        pass

    @mark_no_op
    def leave_RightParen(self, original_node: "RightParen") -> None:
        pass

    @mark_no_op
    def leave_RightShift(self, original_node: "RightShift") -> None:
        pass

    @mark_no_op
    def leave_RightShiftAssign(self, original_node: "RightShiftAssign") -> None:
        pass

    @mark_no_op
    def leave_RightSquareBracket(self, original_node: "RightSquareBracket") -> None:
        pass

    @mark_no_op
    def leave_Semicolon(self, original_node: "Semicolon") -> None:
        pass

    @mark_no_op
    def leave_Set(self, original_node: "Set") -> None:
        pass

    @mark_no_op
    def leave_SetComp(self, original_node: "SetComp") -> None:
        pass

    @mark_no_op
    def leave_SimpleStatementLine(self, original_node: "SimpleStatementLine") -> None:
        pass

    @mark_no_op
    def leave_SimpleStatementSuite(self, original_node: "SimpleStatementSuite") -> None:
        pass

    @mark_no_op
    def leave_SimpleString(self, original_node: "SimpleString") -> None:
        pass

    @mark_no_op
    def leave_SimpleWhitespace(self, original_node: "SimpleWhitespace") -> None:
        pass

    @mark_no_op
    def leave_Slice(self, original_node: "Slice") -> None:
        pass

    @mark_no_op
    def leave_StarredDictElement(self, original_node: "StarredDictElement") -> None:
        pass

    @mark_no_op
    def leave_StarredElement(self, original_node: "StarredElement") -> None:
        pass

    @mark_no_op
    def leave_Subscript(self, original_node: "Subscript") -> None:
        pass

    @mark_no_op
    def leave_Subtract(self, original_node: "Subtract") -> None:
        pass

    @mark_no_op
    def leave_SubtractAssign(self, original_node: "SubtractAssign") -> None:
        pass

    @mark_no_op
    def leave_TrailingWhitespace(self, original_node: "TrailingWhitespace") -> None:
        pass

    @mark_no_op
    def leave_Try(self, original_node: "Try") -> None:
        pass

    @mark_no_op
    def leave_Tuple(self, original_node: "Tuple") -> None:
        pass

    @mark_no_op
    def leave_UnaryOperation(self, original_node: "UnaryOperation") -> None:
        pass

    @mark_no_op
    def leave_While(self, original_node: "While") -> None:
        pass

    @mark_no_op
    def leave_With(self, original_node: "With") -> None:
        pass

    @mark_no_op
    def leave_WithItem(self, original_node: "WithItem") -> None:
        pass

    @mark_no_op
    def leave_Yield(self, original_node: "Yield") -> None:
        pass


class CSTTypedTransformerFunctions(CSTTypedBaseFunctions):
    pass

    @mark_no_op
    def leave_Add(
        self, original_node: "Add", updated_node: "Add"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_AddAssign(
        self, original_node: "AddAssign", updated_node: "AddAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_And(
        self, original_node: "And", updated_node: "And"
    ) -> Union["BaseBooleanOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_AnnAssign(
        self, original_node: "AnnAssign", updated_node: "AnnAssign"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Annotation(
        self, original_node: "Annotation", updated_node: "Annotation"
    ) -> Union["Annotation", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Arg(
        self, original_node: "Arg", updated_node: "Arg"
    ) -> Union["Arg", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_AsName(
        self, original_node: "AsName", updated_node: "AsName"
    ) -> Union["AsName", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Assert(
        self, original_node: "Assert", updated_node: "Assert"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Assign(
        self, original_node: "Assign", updated_node: "Assign"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_AssignEqual(
        self, original_node: "AssignEqual", updated_node: "AssignEqual"
    ) -> Union["AssignEqual", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_AssignTarget(
        self, original_node: "AssignTarget", updated_node: "AssignTarget"
    ) -> Union["AssignTarget", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Asynchronous(
        self, original_node: "Asynchronous", updated_node: "Asynchronous"
    ) -> Union["Asynchronous", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Attribute(
        self, original_node: "Attribute", updated_node: "Attribute"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_AugAssign(
        self, original_node: "AugAssign", updated_node: "AugAssign"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Await(
        self, original_node: "Await", updated_node: "Await"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BinaryOperation(
        self, original_node: "BinaryOperation", updated_node: "BinaryOperation"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BitAnd(
        self, original_node: "BitAnd", updated_node: "BitAnd"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BitAndAssign(
        self, original_node: "BitAndAssign", updated_node: "BitAndAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BitInvert(
        self, original_node: "BitInvert", updated_node: "BitInvert"
    ) -> Union["BaseUnaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BitOr(
        self, original_node: "BitOr", updated_node: "BitOr"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BitOrAssign(
        self, original_node: "BitOrAssign", updated_node: "BitOrAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BitXor(
        self, original_node: "BitXor", updated_node: "BitXor"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BitXorAssign(
        self, original_node: "BitXorAssign", updated_node: "BitXorAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_BooleanOperation(
        self, original_node: "BooleanOperation", updated_node: "BooleanOperation"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Break(
        self, original_node: "Break", updated_node: "Break"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Call(
        self, original_node: "Call", updated_node: "Call"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ClassDef(
        self, original_node: "ClassDef", updated_node: "ClassDef"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Colon(
        self, original_node: "Colon", updated_node: "Colon"
    ) -> Union["Colon", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Comma(
        self, original_node: "Comma", updated_node: "Comma"
    ) -> Union["Comma", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Comment(
        self, original_node: "Comment", updated_node: "Comment"
    ) -> Union["Comment", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_CompFor(
        self, original_node: "CompFor", updated_node: "CompFor"
    ) -> Union["CompFor", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_CompIf(
        self, original_node: "CompIf", updated_node: "CompIf"
    ) -> Union["CompIf", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Comparison(
        self, original_node: "Comparison", updated_node: "Comparison"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ComparisonTarget(
        self, original_node: "ComparisonTarget", updated_node: "ComparisonTarget"
    ) -> Union["ComparisonTarget", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ConcatenatedString(
        self, original_node: "ConcatenatedString", updated_node: "ConcatenatedString"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Continue(
        self, original_node: "Continue", updated_node: "Continue"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Decorator(
        self, original_node: "Decorator", updated_node: "Decorator"
    ) -> Union["Decorator", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Del(
        self, original_node: "Del", updated_node: "Del"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Dict(
        self, original_node: "Dict", updated_node: "Dict"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_DictComp(
        self, original_node: "DictComp", updated_node: "DictComp"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_DictElement(
        self, original_node: "DictElement", updated_node: "DictElement"
    ) -> Union["BaseDictElement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Divide(
        self, original_node: "Divide", updated_node: "Divide"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_DivideAssign(
        self, original_node: "DivideAssign", updated_node: "DivideAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Dot(
        self, original_node: "Dot", updated_node: "Dot"
    ) -> Union["Dot", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Element(
        self, original_node: "Element", updated_node: "Element"
    ) -> Union["BaseElement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Ellipsis(
        self, original_node: "Ellipsis", updated_node: "Ellipsis"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Else(
        self, original_node: "Else", updated_node: "Else"
    ) -> Union["Else", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_EmptyLine(
        self, original_node: "EmptyLine", updated_node: "EmptyLine"
    ) -> Union["EmptyLine", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Equal(
        self, original_node: "Equal", updated_node: "Equal"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ExceptHandler(
        self, original_node: "ExceptHandler", updated_node: "ExceptHandler"
    ) -> Union["ExceptHandler", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Expr(
        self, original_node: "Expr", updated_node: "Expr"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ExtSlice(
        self, original_node: "ExtSlice", updated_node: "ExtSlice"
    ) -> Union["ExtSlice", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Finally(
        self, original_node: "Finally", updated_node: "Finally"
    ) -> Union["Finally", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Float(
        self, original_node: "Float", updated_node: "Float"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_FloorDivide(
        self, original_node: "FloorDivide", updated_node: "FloorDivide"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_FloorDivideAssign(
        self, original_node: "FloorDivideAssign", updated_node: "FloorDivideAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_For(
        self, original_node: "For", updated_node: "For"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_FormattedString(
        self, original_node: "FormattedString", updated_node: "FormattedString"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_FormattedStringExpression(
        self,
        original_node: "FormattedStringExpression",
        updated_node: "FormattedStringExpression",
    ) -> Union["BaseFormattedStringContent", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_FormattedStringText(
        self, original_node: "FormattedStringText", updated_node: "FormattedStringText"
    ) -> Union["BaseFormattedStringContent", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_From(
        self, original_node: "From", updated_node: "From"
    ) -> Union["From", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_FunctionDef(
        self, original_node: "FunctionDef", updated_node: "FunctionDef"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_GeneratorExp(
        self, original_node: "GeneratorExp", updated_node: "GeneratorExp"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Global(
        self, original_node: "Global", updated_node: "Global"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_GreaterThan(
        self, original_node: "GreaterThan", updated_node: "GreaterThan"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_GreaterThanEqual(
        self, original_node: "GreaterThanEqual", updated_node: "GreaterThanEqual"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_If(
        self, original_node: "If", updated_node: "If"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_IfExp(
        self, original_node: "IfExp", updated_node: "IfExp"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Imaginary(
        self, original_node: "Imaginary", updated_node: "Imaginary"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Import(
        self, original_node: "Import", updated_node: "Import"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ImportAlias(
        self, original_node: "ImportAlias", updated_node: "ImportAlias"
    ) -> Union["ImportAlias", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ImportFrom(
        self, original_node: "ImportFrom", updated_node: "ImportFrom"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ImportStar(
        self, original_node: "ImportStar", updated_node: "ImportStar"
    ) -> Union["ImportStar", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_In(
        self, original_node: "In", updated_node: "In"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_IndentedBlock(
        self, original_node: "IndentedBlock", updated_node: "IndentedBlock"
    ) -> Union["BaseSuite", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Index(
        self, original_node: "Index", updated_node: "Index"
    ) -> Union["Index", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Integer(
        self, original_node: "Integer", updated_node: "Integer"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Is(
        self, original_node: "Is", updated_node: "Is"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_IsNot(
        self, original_node: "IsNot", updated_node: "IsNot"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Lambda(
        self, original_node: "Lambda", updated_node: "Lambda"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_LeftCurlyBrace(
        self, original_node: "LeftCurlyBrace", updated_node: "LeftCurlyBrace"
    ) -> Union["LeftCurlyBrace", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_LeftParen(
        self, original_node: "LeftParen", updated_node: "LeftParen"
    ) -> Union["LeftParen", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_LeftShift(
        self, original_node: "LeftShift", updated_node: "LeftShift"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_LeftShiftAssign(
        self, original_node: "LeftShiftAssign", updated_node: "LeftShiftAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_LeftSquareBracket(
        self, original_node: "LeftSquareBracket", updated_node: "LeftSquareBracket"
    ) -> Union["LeftSquareBracket", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_LessThan(
        self, original_node: "LessThan", updated_node: "LessThan"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_LessThanEqual(
        self, original_node: "LessThanEqual", updated_node: "LessThanEqual"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_List(
        self, original_node: "List", updated_node: "List"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ListComp(
        self, original_node: "ListComp", updated_node: "ListComp"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_MatrixMultiply(
        self, original_node: "MatrixMultiply", updated_node: "MatrixMultiply"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_MatrixMultiplyAssign(
        self,
        original_node: "MatrixMultiplyAssign",
        updated_node: "MatrixMultiplyAssign",
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Minus(
        self, original_node: "Minus", updated_node: "Minus"
    ) -> Union["BaseUnaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Module(
        self, original_node: "Module", updated_node: "Module"
    ) -> Union["Module", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Modulo(
        self, original_node: "Modulo", updated_node: "Modulo"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ModuloAssign(
        self, original_node: "ModuloAssign", updated_node: "ModuloAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Multiply(
        self, original_node: "Multiply", updated_node: "Multiply"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_MultiplyAssign(
        self, original_node: "MultiplyAssign", updated_node: "MultiplyAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Name(
        self, original_node: "Name", updated_node: "Name"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_NameItem(
        self, original_node: "NameItem", updated_node: "NameItem"
    ) -> Union["NameItem", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Newline(
        self, original_node: "Newline", updated_node: "Newline"
    ) -> Union["Newline", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Nonlocal(
        self, original_node: "Nonlocal", updated_node: "Nonlocal"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Not(
        self, original_node: "Not", updated_node: "Not"
    ) -> Union["BaseUnaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_NotEqual(
        self, original_node: "NotEqual", updated_node: "NotEqual"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_NotIn(
        self, original_node: "NotIn", updated_node: "NotIn"
    ) -> Union["BaseCompOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Or(
        self, original_node: "Or", updated_node: "Or"
    ) -> Union["BaseBooleanOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Param(
        self, original_node: "Param", updated_node: "Param"
    ) -> Union["Param", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ParamStar(
        self, original_node: "ParamStar", updated_node: "ParamStar"
    ) -> Union["ParamStar", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Parameters(
        self, original_node: "Parameters", updated_node: "Parameters"
    ) -> Union["Parameters", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_ParenthesizedWhitespace(
        self,
        original_node: "ParenthesizedWhitespace",
        updated_node: "ParenthesizedWhitespace",
    ) -> Union["BaseParenthesizableWhitespace", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Pass(
        self, original_node: "Pass", updated_node: "Pass"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Plus(
        self, original_node: "Plus", updated_node: "Plus"
    ) -> Union["BaseUnaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Power(
        self, original_node: "Power", updated_node: "Power"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_PowerAssign(
        self, original_node: "PowerAssign", updated_node: "PowerAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Raise(
        self, original_node: "Raise", updated_node: "Raise"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Return(
        self, original_node: "Return", updated_node: "Return"
    ) -> Union["BaseSmallStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_RightCurlyBrace(
        self, original_node: "RightCurlyBrace", updated_node: "RightCurlyBrace"
    ) -> Union["RightCurlyBrace", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_RightParen(
        self, original_node: "RightParen", updated_node: "RightParen"
    ) -> Union["RightParen", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_RightShift(
        self, original_node: "RightShift", updated_node: "RightShift"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_RightShiftAssign(
        self, original_node: "RightShiftAssign", updated_node: "RightShiftAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_RightSquareBracket(
        self, original_node: "RightSquareBracket", updated_node: "RightSquareBracket"
    ) -> Union["RightSquareBracket", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Semicolon(
        self, original_node: "Semicolon", updated_node: "Semicolon"
    ) -> Union["Semicolon", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Set(
        self, original_node: "Set", updated_node: "Set"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_SetComp(
        self, original_node: "SetComp", updated_node: "SetComp"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_SimpleStatementLine(
        self, original_node: "SimpleStatementLine", updated_node: "SimpleStatementLine"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_SimpleStatementSuite(
        self,
        original_node: "SimpleStatementSuite",
        updated_node: "SimpleStatementSuite",
    ) -> Union["BaseSuite", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_SimpleString(
        self, original_node: "SimpleString", updated_node: "SimpleString"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_SimpleWhitespace(
        self, original_node: "SimpleWhitespace", updated_node: "SimpleWhitespace"
    ) -> Union["BaseParenthesizableWhitespace", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Slice(
        self, original_node: "Slice", updated_node: "Slice"
    ) -> Union["Slice", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_StarredDictElement(
        self, original_node: "StarredDictElement", updated_node: "StarredDictElement"
    ) -> Union["BaseDictElement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_StarredElement(
        self, original_node: "StarredElement", updated_node: "StarredElement"
    ) -> Union["BaseElement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Subscript(
        self, original_node: "Subscript", updated_node: "Subscript"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Subtract(
        self, original_node: "Subtract", updated_node: "Subtract"
    ) -> Union["BaseBinaryOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_SubtractAssign(
        self, original_node: "SubtractAssign", updated_node: "SubtractAssign"
    ) -> Union["BaseAugOp", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_TrailingWhitespace(
        self, original_node: "TrailingWhitespace", updated_node: "TrailingWhitespace"
    ) -> Union["TrailingWhitespace", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Try(
        self, original_node: "Try", updated_node: "Try"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Tuple(
        self, original_node: "Tuple", updated_node: "Tuple"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_UnaryOperation(
        self, original_node: "UnaryOperation", updated_node: "UnaryOperation"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_While(
        self, original_node: "While", updated_node: "While"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_With(
        self, original_node: "With", updated_node: "With"
    ) -> Union["BaseStatement", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_WithItem(
        self, original_node: "WithItem", updated_node: "WithItem"
    ) -> Union["WithItem", MaybeSentinel, RemovalSentinel]:
        return updated_node

    @mark_no_op
    def leave_Yield(
        self, original_node: "Yield", updated_node: "Yield"
    ) -> Union["BaseExpression", MaybeSentinel, RemovalSentinel]:
        return updated_node
